Close Reader View

  * Text and layout
  *


        Text

    Text size

    Font

    Font weight

    ------------------------------------------------------------------------


        Layout

    ------------------------------------------------------------------------


        Advanced

    Text alignment

    Reset defaults

  * Theme
  *


        Theme

    Default

    Custom

    Auto

    Light

    Dark

    Sepia

    Contrast

    Gray

      o
      o
      o
      o
  o
    Reset defaults

  * Read aloud (N)
  *


        Read aloud

    ------------------------------------------------------------------------


        Voice

    Default

    DefaultMicrosoft Zira Desktop - English (United States)

bartwronski.com <https://bartwronski.com/2016/10/30/dithering-part-
three-real-world-2d-quantization-dithering/>


  Dithering part three ‚Äì real world 2D quantization dithering

Posted on
10‚Äì13 minutes
------------------------------------------------------------------------

In previous two parts <https://bartwronski.com/2016/10/30/dithering-
part-two-golden-ratio-sequence-blue-noise-and-highpass-and-remap/> of
this blog post mini-series <https://bartwronski.com/2016/10/30/
dithering-in-games-mini-series/> I described basic uses mentioned blue
noise definition, referenced/presented 2 techniques of generating blue
noise and one of many general purpose high-frequency low-discrepancy
sampling sequences.

In this post, we will look at some more practical example ‚Äì use of
(blue) noise in *2D image* dithering for quantization!

You can find Mathematica notebook for this post here <https://
raw.githubusercontent.com/bartwronski/BlogPostsExtraMaterial/master/
DitheringPostSeries/2ddithering.nb> and its pdf version here <https://
github.com/bartwronski/BlogPostsExtraMaterial/blob/master/
DitheringPostSeries/2ddithering.pdf>.


    Bit quantization in 2D

Finally, we are getting to some practical use case. When you encode your
images in 8 bits (typical framebuffer) ‚Äì you are *quantizing*. When you
encode your GBuffers, render targets and others ‚Äì you are quantizing.
Even typical 8 bit is enough to cause some *banding* on very smooth,
slow gradients ‚Äì like skies or lens flares.

We will cover here a more extreme example though ‚Äì extreme *3 bit*
quantization of a linear gradient.

2dditheringorigsignal.png

2dditheringquantizenodither.png

We call those quantization artifacts ‚Äì 8 visible bands the ‚Äú/banding/‚Äù
effect.

As we learned in previous parts, we can try to fix it by applying some
noise. At first, let‚Äôs try regular, white noise:

2dditheringquantizewhitenoise.png

Doesn‚Äôt look too good. There are 2 problems:

  * ‚ÄúClumping‚Äù of areas, identical to one we have learned before and we
    will address it in this post.
  * Still visible ‚Äúbands‚Äù of unchanged values ‚Äì around center of bands
    (where banding effect was not contributing to too much error.

2dditheringwhitebands.gif

Error visualized.

Those bands are quite distracting. We could try ti fix them by dithering
even more (beyond the error):

2dditheringquantizewhitenoisex2.png

This solves this one problem! However image is too noisy now.

There is a much better solution that was described very well by Mikkel
Gjoel <http://loopit.dk/banding_in_games.pdf>.

Using triangular noise distribution fixes those bands without over-
noising the image:

2dditheringquantizewhitenoisetriangle.png

Use of triangular noise distribution.

Since this is a well covered topic and it complicates analysis a bit
(different distributions), I will not be using this fix for most of this
post. So those bands will stay there, but we will still compare some
distributions.


    Fixed dithering patterns

In previous part we looked at golden ratio sequence. It is well defined
and simple for 1D, however doesn‚Äôt work / isn‚Äôt defined in 2D (if we
want it to be uniquely defined).

One of oldest, well known and used 2D dithering patterns is so called
*Bayer matrix* or ordered Bayer. It is defined as a recursive matrix of
a simple pattern for level zero:

    1 2

    3 0

With next levels defined as:

    4*I(n-1) + 1  ‚Äî‚Äì 4*I(n-1) + 2

    4*I(n-1) + 3  ‚Äî‚Äì 4*I(n-1) + 0

It can be replicated with a simple Mathematica snippet:

    Bayer[x_, y_, level_] :=
    Mod[Mod[BitShiftRight[x, level], 2] + 1 + 2*Mod[BitShiftRight[y,
    level], 2],
       4] + If[level == 0, 0, 4*Bayer[x, y, level ‚Äì 1]]

2dditheringbayer.png

8√ó8 ordered Bayer matrix

What is interesting (and quite limiting) about Bayer is that due to its
recursive nature, signal difference is maximized only in this small 2√ó2
neighborhood, so larger Bayer matrices add more intermediate steps /
values, but don‚Äôt contribute much to any *visible* pattern difference.
Therefore most game engines that I have seen used up to 4√ó4 Bayer
pattern with 16 distinctive values.

If you plot a periodogram (frequency spectrum) of it, you will clearly
see only 2 single, very high frequency dots!

2dditheringbayerperiodogram.png

2D periodogram ‚Äì low frequencies are in the middle and high frequencies
to the sides.

Obviously signal has some other frequencies, but much lower intensities‚Ä¶
Plotting it in log scale fixes it:

2dditheringbayerperiodogramlogscale.png

So on one hand, Bayer matrix has lots of high frequency ‚Äì would seem
perfect for dithering. However presence of strong single frequency bands
tends to alias it heavily and produce ugly pattern look.

This is our quantized function:

2dditheringquantizebayer.png

If you have been long enough playing with computers to remember 8 bit or
16 bit color modes and *palletized* images, this will look very familiar
‚Äì as lots of algorithms used this matrix. It is very cheap to apply (a
single look up from an array or even bit-magic ops few ALU instructions)
and has optimum high frequency content. At the same time, it produces
this very visible unpleasant patterns. They are much worse for sampling
and in temporal domain (next 2 parts of this series), but for now let‚Äôs
have a look at some better sequence.


    Interleaved gradient noise

The next sequence that I this is working extremely well for many
dithering-like tasks, is ‚Äúinterleaved gradient noise‚Äù by Jorge Jimenez
<http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-
advanced-warfare>.

Formula is extremely simple!

    InterleavedGradientNoise[x_, y_] :=
    FractionalPart[52.9829189*FractionalPart[0.06711056*x + 0.00583715*y]]

But the results look great, contain lots of high frequency and produce
pleasant, interleaved smooth gradients (be sure to check Jorge‚Äôs
original presentation and his decomposition of ‚Äúgradients‚Äù):

interleavedgradientnoise.png

What is even more impressive is that such pleasant visual pattern was
invented by him as a result of *optimization* of some ‚Äúcommon web
knowledge‚Äù hacky noise hashing functions!

Unsurprisingly, this pattern has periodogram containing frequencies that
correspond to those interleaved gradients + their frequency aliasing
(result of frac ‚Äì similar to frequency aliasing of a saw wave):

2dditheringinterleavedgradientnoiseperiodogram.png

And the 3D plot (spikes corresponding to those frequency):

2ddithering3dplotinterleaved.png

Just like with Bayer, those frequencies will be prone to aliasing and
‚Äúresonating‚Äù with frequencies in source image, but almost zero low
frequencies given nice, clean smooth look:

2dditheringquantizeinterleavedgradient.png

Some ‚Äúhatching‚Äù patterns are visible, but they are much more gradient-
like (like the name of the function) and therefore less distracting.


    Blue noise

Finally, we get again to using a blue noise pre-generated pattern. To
recall from previous part, blue noise is loosely defined as a noise
function with small low frequency component and uniform coverage of
different frequencies. I will use here a pattern that again I generated
using my naive implementation <https://github.com/bartwronski/
BlueNoiseGenerator/> of ‚ÄúBlue-noise Dithered Sampling‚Äù <https://
www.solidangle.com/research/dither_abstract.pdf> by Iliyan Georgiev and
Marcos Fajardo.

So I generated a simple 64√ó64 wrapping blue noise-like sequence (a
couple hours on an old MacBook):

2dbluenoise.png

It has following periodogram / frequency content:

2dditheringblueperiodogram.png

And in 3D (who doesn‚Äôt love visualizations?! üòÄ ):

2ddithering3dplot.png

Compared to white noise, it has a big ‚Äúhole‚Äù in the middle,
corresponding to low frequencies.

2dwhitenoisevsbluenoise.gif

White noise vs blue noise in 2D

At the same time, it doesn‚Äôt have linear frequency increase for higher
frequencies, like audio / academic definition of blue noise. I am not
sure if it‚Äôs because my implementation optimization (only 7√ó7
neighborhood is analyzed + not enough iterations) or the original paper,
but doesn‚Äôt seem to impact the results for our use case in a negative way.

Without further ado, results of dithering using 2D blue noise:
2dditheringquantizeblue.png

It is 64√ó64 pattern, but it is optimized for wrapping around ‚Äì so border
pixels error metric is computed with taking into account pixels on the
other side of the pattern. In this gradient, it is repeated 2√ó2.

And this is how it compared to regular white noise:

2dwhitenoisevsbluenoise.gif

White noise vs blue noise

Because of high frequency contents only, you can‚Äôt see this problematic
‚Äúclumping‚Äù effect.

It also means that if we oversample (like with all those new fancy 1080p
-> 1440p -> 2160p displays), blur it or apply temporal (one of next
parts), it will be more similar to original pattern! So when we filter
them with 2-wide *Gaussian*:

2dditheringwhitevsbluefiltered.png

Left: Gaussian-filtered white noise dithering. Right: Gaussian-filtered
blue noise dithering.

And while I said we will not be looking at triangle noise distribution
in this post for simplicity, I couldn‚Äôt resist the temptation of
comparing them:

2dwhitenoisevsbluenoisetriangle.gif

White noise vs blue noise with triangular distribution remapping applied.

I hope that this at least hints at an observation that with a good, well
distributed large enough blue noise fixed pattern you might get results
maybe not the same quality level of error diffusion dithering, but in
that direction and orders of magnitude better than standard white noise.


    All four compared

Just some visual comparison of all four techniques:

2dditheringallfourcompared.png

White noise, blue noise, Bayer, interleaved gradient noise

2dditheringalltechniquescompared.gif

And with the triangular remapping:

2dditheringallfourcomparedtriangular.png

2dditheringallfourcomparedtriangular.gif

My personal final recommendations and conclusions and here would be:

  * Whenever possible, avoid ordered Bayer! Many game engines and
    codebases still use it, but it produces very visible unpleasant
    patterns. I still see it in some currently shipped games!
  * If you cannot spare any memory look-ups but have some ALU, use
    excellent interleaved gradient noise by Jorge Jimenez. It produces
    much more pleasant patterns and is extremely cheap with GPU
    instruction set! However patterns are still noticeable and it can alias.
  * Blue noise is really great noise distribution for many dithering
    tasks and if you have time to generate it and memory to store it +
    bandwidth to fetch, it is the way to go.
  * White noise is useful for comparison / ground truth. With pixel
    index hashing it‚Äôs easy to generate <http://www.reedbeta.com/blog/
    quick-and-easy-gpu-random-numbers-in-d3d11/>, so it‚Äôs useful to keep
    it around.


    Summary

In this part of the series, I looked at the topic of quantization of 2D
images for the purpose of storing them at limited bit depth. I analyzed
looks and effects of white noise, ordered Bayer pattern matrices,
interleaved gradient noise and blue noise.

In next part of the series (coming soon), we will have a look at the
topic of dithering in more complicated (but also very common) scenario ‚Äì
uniform sampling. It is slightly different, because often requirements
are different. For example if you consider rotations, values of 0 and
2pi will ‚Äúwrap‚Äù and be identical ‚Äì therefore we should adjust our noise
distribution generation error metric for this purpose. Also, for most
sampling topics we will need to consider more that 1 value of noise.

Blog post mini-series index <https://bartwronski.com/2016/10/30/
dithering-in-games-mini-series/>.

*Edit 10/31/2016*: Fixed triangular noise remapping to work in -1 ‚Äì 1
range instead of -0.5-1.5. Special thanks to Romain Guy and Mikkel Gjoel
for pointing out the error.


    References

http://loopit.dk/banding_in_games.pdf <http://loopit.dk/
banding_in_games.pdf> ‚ÄúBanding in games‚Äù, Mikkel Gjoel

https://engineering.purdue.edu/~bouman/ece637/notes/pdf/Halftoning.pdf
<https://engineering.purdue.edu/~bouman/ece637/notes/pdf/
Halftoning.pdf> C. A. Bouman: Digital Image Processing ‚Äì January 12, 2015

B. E. Bayer, ‚ÄúAn optimum method for two-level rendition of continuous-
tone pictures‚Äù, IEEE Int. Conf. Commun., Vol. 1, pp. 26-1 1-26-15 (1973).

http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-
advanced-warfare <http://www.iryoku.com/next-generation-post-processing-
in-call-of-duty-advanced-warfare> ‚ÄúNext generation post-processing in
Call of Duty: Advanced Warfare‚Äù, Jorge Jimenez, Siggraph 2014 ‚ÄúAdvances
in Real Time Rendering in games‚Äù

‚ÄúBlue-noise Dithered Sampling‚Äù <https://www.solidangle.com/research/
dither_abstract.pdf>, Iliyan Georgiev and Marcos Fajardo

https://github.com/bartwronski/BlueNoiseGenerator  <https://github.com/
bartwronski/BlueNoiseGenerator>

http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
<http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-
d3d11/> ‚ÄúQuick And Easy GPU Random Numbers In D3D11‚Äù, Nathan Reed

